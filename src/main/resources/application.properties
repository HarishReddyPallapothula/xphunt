spring.application.name=xphunt

# ===================================================================
# SERVER CONFIGURATION
# ===================================================================
server.port=8080

# ===================================================================
# DATABASE CONFIGURATION (PostgreSQL)
# ===================================================================
# This section configures the connection to your PostgreSQL database.

# The JDBC URL for PostgreSQL.
# Format: jdbc:postgresql://<host>:<port>/<database_name>
# 'localhost:5432' is the standard default for a local PostgreSQL installation.
# Replace 'your_database_name' with the actual name of your database.
spring.datasource.url=jdbc:postgresql://localhost:5432/XPHUNT

# The username for your PostgreSQL database user.
spring.datasource.username=postgres

# The password for your PostgreSQL database user.
spring.datasource.password=sergtsoP@321

# The fully qualified name of the JDBC driver. Spring Boot can often infer this,
# but it's good practice to be explicit.
spring.datasource.driver-class-name=org.postgresql.Driver


# ===================================================================
# JPA / HIBERNATE CONFIGURATION for PostgreSQL
# ===================================================================

# Specify the PostgreSQL dialect for Hibernate. This tells Hibernate how to
# generate SQL statements that are compatible with PostgreSQL.
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# DDL (Data Definition Language) Auto-Configuration Strategy.
#
# IMPORTANT: Choose the right strategy for your environment.
#
# 'update': (Good for early development) Hibernate attempts to update the schema
#           to match your entities. Can be risky as it may not handle complex
#           changes like column renames correctly.
# 'validate': (Good for production) Hibernate checks if the DB schema matches
#             your entities on startup and throws an error if there's a mismatch.
# 'create-drop': (Good for integration tests) Creates schema on startup, drops on shutdown.
# 'none': (BEST for production) Hibernate does nothing to the schema. You are
#         responsible for managing schema changes yourself, typically with a
#         database migration tool like Flyway or Liquibase.
spring.jpa.hibernate.ddl-auto=update

# Show the SQL generated by Hibernate in the logs. Invaluable for debugging.
spring.jpa.show-sql=true

# Make the logged SQL more readable by formatting it.
spring.jpa.properties.hibernate.format_sql=true

# Naming strategy for table and column names.
# This strategy converts camelCase (e.g., 'totalXp') to snake_case (e.g., 'total_xp').
# This is a common convention for SQL databases and highly recommended.
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


# ===================================================================
# JWT SECRET KEY & LOGGING CONFIGURATION (Remains the same)
# ===================================================================
app.jwt.secret=bXktc3VwZXItc2VjcmV0LWtleS1mb3Itand0LXNpZ25pbmctdGhhdC1pcy1sb25nLWVub3VnaA==
app.jwt.expiration-ms=3600000

#logging.level.root=INFO
#logging.level.com.yourapplication.package=DEBUG
#logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n


